package com.payneteasy.srvlog.adapter.syslog;

import static com.google.common.hash.Hashing.md5;
import static java.nio.charset.StandardCharsets.UTF_8;
import java.text.DateFormat;
import java.util.Date;
import static java.util.Locale.ENGLISH;
import jregex.Matcher;
import jregex.Pattern;
import org.joda.time.DateTime;
import static org.joda.time.format.DateTimeFormat.forPattern;
import org.joda.time.format.DateTimeFormatter;

/**
 * Object representation of snort message, processed by ossec.
 *
 * @author imenem
 */
public class OssecSnortMessage {

    /**
     * Regular expression to parse message.
     */
    private final static Pattern MESSAGE_REGEX = new Pattern(
        "({DATE}[A-Z][a-z]{2} +\\d{1,2} \\d{1,2}:\\d{2}:\\d{2})" +
        ".+? ossec: Alert Level:.+?" +
        "snort\\[\\d+\\]: " +
        "({IDENTIFIER}\\[\\d+:\\d+:\\d+\\])"
    );

    /**
     * Return true, if message generated by ossec and contains message from snort.
     *
     * @param       rawMessage      Message to ckeck.
     *
     * @return      True, if message generated by ossec and contains message from snort.
     */
    public static boolean isSnortMessageFromOssec(String rawMessage) {
        return MESSAGE_REGEX.matcher(rawMessage).find();
    }

    /**
     * Parses message generated by ossec and contains message from snort.
     *
     * @param       rawMessage      Message to parse.
     *
     * @return      Object representation of snort message, processed by ossec.
     */
    public static OssecSnortMessage createOssecSnortMessage(String rawMessage) {
        OssecSnortMessage snortMessage = new OssecSnortMessage();

        Matcher matcher = MESSAGE_REGEX.matcher(rawMessage);

        if (!matcher.find()) {
            throw new RuntimeException(
                "Message does not look like message from Ossec with snort alert. " +
                "Check message with method isSnortMessageFromOssec() first."
            );
        }

        snortMessage.setDate(matcher.group("DATE"));
        snortMessage.identifier = matcher.group("IDENTIFIER");
        snortMessage.hash = md5().hashString(rawMessage, UTF_8).toString();

        return snortMessage;
    }

    /**
     * Date and time parser.
     * Uses UTC time zone.
     *
     * {@link DateFormat} isn't thread safe, so we must create
     * own instance of {@link DateFormat} for each {@link SnortMessage} object.
     */
    private DateTimeFormatter dateParser = forPattern("MMM d HH:mm:ss").withLocale(ENGLISH).withZoneUTC();

    /**
     * Date and time, when ossec finished incoming messages collecting and generated this message.
     */
    private DateTime dateTo;

    /**
     * Date and time, when ossec possibly started incoming messages collecting.
     */
    private DateTime dateFrom;

    /**
     * Message identifier, generated by snort.
     */
    private String identifier;

    /**
     * Original ossec message hash.
     */
    private String hash;

    /**
     * Returns message identifier, generated by snort.
     *
     * @return      Message identifier.
     */
    public String getIdentifier() {
        return identifier;
    }

    /**
     * Returns original ossec message hash.
     *
     * @return      Message hash.
     */
    public String getHash() {
        return hash;
    }

    public Date getDateTo() {
        return dateTo.toDate();
    }

    public Date getDateFrom() {
        return dateFrom.toDate();
    }

    /**
     * Converts date from string to object and assigns it to object field.
     *
     * @param       date        Date and time, when message generated in string form.
     */
    private void setDate(String dateString) {
        // Date has no year, so we must set in here.
        // Application processes fresh messages, so this solution is usable.
        // Application can be runned for a long time, so we must check year every time.
        int currentYear = new DateTime().getYear();

        if (dateParser.getDefaultYear() != currentYear) {
            dateParser = dateParser.withDefaultYear(currentYear);
        }

        DateTime creationDate = dateParser.parseDateTime(dateString.replaceAll(" +", " "));

        dateTo = creationDate.plusMinutes(1);
        dateFrom = dateTo.minusMinutes(5);
    }

}
